---
layout: page
title: ROP Structure
nav_order: 0
---

# ROP Structure

ROPs are the core of the RayTK library. A ROP is essentially some chunks of GLSL code, and some metadata.

A ROP is a COMP that generates a Definition, which is output as a DAT table.

## ROP Definitions

Inside each ROP there's an `opDefinition` component.

It includes settings that define the properties of the ROP.

### OpDefinition Settings

* General settings
  * `Enable`: Whether the ROP should be used or bypassed. Typically this is bound to a parameter of the same name on the ROP itself.
  * `Useruntimebypass`: Whether the `Enable` parameter (if it exists) should be handled like any other runtime parameter, or, when this is false, switching off the `Enable` parameter totally excludes the OP from the scene, just passing through the first input definition.
  * `Hostop`: Reference to the parent ROP. This should always be `..` to refer to the parent comp.
  * `Paramsop`: Optional reference to an operator that holds the ROP's parameters. This should be blank except in the rare case of operators that support adding custom parameters like `customOp`.
  * `Name`: Globally unique name for the ROP, based on its path. This should always be an expression that pulls its value from inside the `opDefinition`.
  * `Style`: Optional setting that controls how the ROP's viewer image appears. In nearly all cases this should be blank.
  * `Librarynames`: List of either names of globally available shared shader libraries (`raytkCombine`) and/or references to DATs inside the ROP that are injected into the shader (deduplicated to avoid conflicts if multiple ROP instances provide equivalent libraries).
  * `Typespec`: Reference to the `typeSpec` component that defines the data types used by the ROP. See below.
  * `Inputdefs`: Optional list of additional ROP definition tables to be included as inputs. This is used for cases where there are more than 8 inputs, or when there are inputs that have special handling.
  * `Disableinspect`: Whether the ROP supports the `Inspect` feature to launch the Inspector tool.
* Code blocks (references to DATs that contain blocks of glsl code)
  * `Opglobals`: Global declarations, such as variables that are shared across multiple calls of the ROP's main function code. This is not commonly used.
  * `Initcode`: Executable code that is called once at the beginning of the shader execution. This can be used to initialize global variables. It is not commonly used.
  * `Functemplate`: Required declaration of the ROP's primary function. It can also include additional functions or other declarations that are specific to this particular instance of this type of ROP.
  * `Materialcode`: Optional executable code that materials use to produce colors when rendering. This is only used for material operators (e.g. `modularMat`, `basicMat`), and it's typically just a call to a secondary function that's defined in the `Functemplate`.
* Tables (references to tables that specify one or more items that belong to the ROP).
  * `Macrotable`: Compiler macros which produce `#define`s in the generated shader.
  * `Buffertable`: Uniform arrays and/or `samplerBuffer`s which pass arrays of values into the shader.
  * `Texturetable`: TOP inputs that are fed into the shader and referenced with `sampler*` uniforms.
  * `Variabletable`: Definitions of variables that the operator can provide to other operators. See [`Variables`](/raytk/development/variables/).
  * `Referencetable`: Definitions of references to variables from other operators. This is only used by `variableReference`.
  * `Dispatchtable`: Not implemented.
  * `Tagtable`: Tags that indicate whether this operator uses certain renderer features like shadows or lights or surface color attributes.
  * `Generatedmacrotables` : Optional list of additional DATs handled like `Macrotable`. This is typically used for tables that are generated by helper components inside the ROP.
  * `Paramgrouptable`: Definitions of parameters that are passed into the shader as either uniforms, macros, or specialization constants.
  * `Callbacks`: Python functions which can be called on certain events like the initial creation of the ROP.
* Metadata (mostly used for the palette and other tools)
  * `Help`: Optional DAT that contains help text. This is stripped out in the build process and moved to the documentation site.
  * `Helpurl`: Link to the page on the documentation site for this ROP.
  * `Displaycategory`: Category where the ROP is listed in the palette.
  * `Shortcuts`: Keyboard shortcuts for the palette search box.
  * `Keywords`: Keywords that are used when searching for ROPs in the palette.

## Generated Definition tables

Inside each ROP, an `opDefinition` COMP is used to construct the definition.

A definition contains:

* `name`: globally unique name for the ROP, based on the path.
* `path`: path to the ROP.
* `opType`: identifies the type of ROP, and is derived from the path of the clone master used to create a ROP.
* `opVersion`: version of that particular type of ROP.
* `functionPath`: path to a text DAT containing the main chunk of code.
* `paramSource`: path to a CHOP containing the values of the parameters for the ROP.
* `paramTable`: path to a table listing the globally unique names of the ROP's individual parameters.
* `paramTupletTable`: path to a table with details about the parameters, organized into tuplets.
* `materialTable`: path to a table listing out the material identifiers used by the ROP.
* `macroTable`: path to a table with preprocessor macros used by the ROP's code.
* `textureTable`: path to a table listing out texture sources used by the ROP.
* `libraryNames`: names or paths of shared libraries that the ROP depends on.
* `initPath`: path to a text DAT with initialization code that the ROP needs to run before its other code is used.
* `opGlobalsPath`: path to a text DAT with declarations of global variables used by the ROP (generally initialized using the code from the `initPath`).
* `coordType`: the type of coordinates that the ROP's function accepts.
* `returnType`: the type of value the that the ROP's function returns.
* `contextType`: the type of context that the ROP's function expects along with the coordinates.
* `inputNames`: the names of other ROPs that this ROP's function calls.

## ROP Functions and GLSL Types

Each ROP has a main function that it contributes to the shader. All of these functions take in two parameters: coordinates, and context, and return a single value.

```glsl
ReturnT sphere1(CoordT p, ContextT ctx) {
  return createSdf(length(p));
}
```

### Coordinate types

* `vec3`: 3D coordinates, such as a position along a ray as it is marching along through space.
* `vec2`: 2D coordinates, such as screen-space UV coordinates, texture coordinates, or positions used for 2D SDFs.
* `float`: 1D coordinates, which can be used for things like looking up how much to apply an effect based on distance from some point, or how to blend between two values.

### Context types

Each ROP function takes a second parameter that is used to pass along additional information about the context in which the function is being called. ROPs often don't make use of this, but they need to pass it along when calling other ROPs since they might need it.

* `Context`: This is the most common type, which is used when evaluating an SDF during raymarching. It contains fields like `iteration`, which is used in cases like the `reflect` ROP so its input can do something different depending on which side of the reflection plane it's on.
* `LightContext`: Used by light ROPs to pass along information about the surface that it is being applied to and the normal direction.
* `MaterialContext`: Used by materials to pass along information about the surface that it is being applied to, the light that's being used, and where the ray that hit it came from.
* `CameraContext`: Used by cameras to pass along information like the output resolution.
* `RayContext`: Used by ray modifiers that bend or alter rays.

### Return types

Each ROP function produces a single return value.

* `Sdf`: The result of a signed distance function (SDF), representing what the closest shape is and how far it is from the ray position. It also contains information like which material to use.
* `float`: A single numeric value. This can be used for value fields that determine how much of something to apply based on a position in space.
* `vec4`: 4 numeric values. This can be used for vector fields or colors.
* `Ray`: A position in 3D space and a direction. Cameras return one of these for each pixel in the ouput.
* `Light`: Information about how much color is provided by a light to a surface.
